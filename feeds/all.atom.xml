<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Vlad's blog</title><link href="https://vladcalin.github.io/" rel="alternate"></link><link href="https://vladcalin.github.io/feeds/all.atom.xml" rel="self"></link><id>https://vladcalin.github.io/</id><updated>2017-02-27T20:48:00+01:00</updated><entry><title>What is microservices?</title><link href="https://vladcalin.github.io/what-is-microservices.html" rel="alternate"></link><published>2017-02-06T15:15:00+01:00</published><updated>2017-02-06T15:15:00+01:00</updated><author><name>Vlad Calin</name></author><id>tag:vladcalin.github.io,2017-02-06:/what-is-microservices.html</id><summary type="html">&lt;p&gt;The title is a reference to the famous &lt;em&gt;"What is drugs?"&lt;/em&gt; news footage that is out there on the internet (if you don't know it, you can view it
&lt;a href="https://youtu.be/kan_FWhjrMw?t=37s"&gt;here&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;So, what is microservice?&lt;/p&gt;
&lt;p&gt;I am sure that you heard this term and wondered why everybody is talking about it …&lt;/p&gt;</summary><content type="html">&lt;p&gt;The title is a reference to the famous &lt;em&gt;"What is drugs?"&lt;/em&gt; news footage that is out there on the internet (if you don't know it, you can view it
&lt;a href="https://youtu.be/kan_FWhjrMw?t=37s"&gt;here&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;So, what is microservice?&lt;/p&gt;
&lt;p&gt;I am sure that you heard this term and wondered why everybody is talking about it. What is it? What is it good for? What problems does this solve?&lt;/p&gt;
&lt;p&gt;In this article I am going to write a little about this phenomenon that is supposed to change the world (and currently does).&lt;/p&gt;
&lt;h1&gt;So, what is a microservice?&lt;/h1&gt;
&lt;p&gt;A microservice is... well... a service ... that is small... and does things... and is webscale... and... whatever....&lt;/p&gt;
&lt;p&gt;Joking aside, a microservice is a stand-alone service (application) that provides simple and independent functionality for a larger system. By simple and independent functionality I want to say that it is responsible in managing a single kind of information/entities (users, subscriptions, notifications, etc) or as fewer as possible. &lt;/p&gt;
&lt;p&gt;A larger system that is developed by using a microservice architecture is composed from a number of independent microservices that communicate with each other over the network. Such systems can be scaled (horizontaly) more easily, can handle failiures, does not need huge investments in performant hardware.&lt;/p&gt;
&lt;p&gt;With this architecture, there appear multiple problems that must be handled:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;how do these services communicate with each other? How does this affect performance? What happens when the network fails?&lt;/li&gt;
&lt;li&gt;how do these services find out about each other?&lt;/li&gt;
&lt;li&gt;with multiple instances of the same service, how can I balance the load more efficiently?&lt;/li&gt;
&lt;li&gt;how do I handle security?&lt;/li&gt;
&lt;li&gt;many others :(&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These questions are natural but they involve a broader discussion and I am not going to cover these aspects, at least not now.&lt;/p&gt;
&lt;h1&gt;What is it good for?&lt;/h1&gt;
&lt;p&gt;As I said earlier, the major advantage in this architectural design is that we can scale better and easier horizontally and we can handle failiure more efficiently.&lt;/p&gt;
&lt;h2&gt;Scalability&lt;/h2&gt;
&lt;p&gt;Having a single service instance that handles all the operations resulted from user requests, over time, becomes more stressed as more users come and they are more active. So the initial situation looks something like this: we have a single service that handles all the requests. You can check some benchmarks for your favourite web framework to see how many requests per second it can handle before having problems and cause some performance issues. &lt;/p&gt;
&lt;h2&gt;Availability&lt;/h2&gt;
&lt;p&gt;Failure is handled in this manner: you have a number of instances of each service running. There are no two instances of the same service that run on the same node. In this case, let's assume that one node violently dies and everything on it stops working. You lose an instance of your service, but the other running instances can handle the requests that the dead one would normally handle! This is good news because all request are processed! And the chances that more nodes fail at the same time and leaves you with no running instance to handle the requests is very low.&lt;/p&gt;
&lt;h2&gt;Independend deployment&lt;/h2&gt;
&lt;p&gt;Another advantage of the microservice pattern is that each service can be independently deployed. When a service needs to be updated, each instance can be updated at a time so that there will be no downtime, and also it is way faster than deploying a whole monolithic application. Of course, you have to be extra cautious to not screw up the communication between services as they need to continue to communicate with each other.&lt;/p&gt;
&lt;h2&gt;Technologies&lt;/h2&gt;
&lt;p&gt;Because microservies run independently and they only interact via some inter-process communication methods, there are no technological restrictions for each microservice. Each microservice an be written in whatever language you want and what technology stack you want to use. It is no problem. All that matters is that the communication protocol between microservices to be well documented and robust.&lt;/p&gt;
&lt;h1&gt;But all this microservice thing is too hard!&lt;/h1&gt;
&lt;p&gt;Of course, an application that is structured in microservices is harder to maintain than a traditional monolithic application. With the advantages this pattern comes with, of course there are some disadvantages.&lt;/p&gt;
&lt;h2&gt;DevOps skills required&lt;/h2&gt;
&lt;p&gt;In the traditional monolithic architecture is a single application, a single database, a single node and a few processes to monitor and manage. But in the microservice architecture, multiply it by the number of services and the number of nodes you have. There will be a lot of things to keep your eyes on and manage. Imagine that each microservice uses its own database, that is of different kind (one uses MySQL, one uses PostgreSQL, one uses MongoDB and so on) and some guys have to make sure that everything is working as expected. &lt;/p&gt;
&lt;p&gt;And as the application grows and more microservices are added and as more and more users use that application, there will be a lot more things to handle and things can go messy very easy.&lt;/p&gt;
&lt;h2&gt;Latency&lt;/h2&gt;
&lt;p&gt;Because each microservice runs independently, eventually on multiple nodes, they need to communicate. What in the classic monolithic architecture every communication between two "services" are simple function calls, but in the microservice architecture, every call becomes a request (be it HTTP, message over AMQP, or some custom protocol over sockets). If a service takes more than a few microseconds to respond, that response time is added to the total response time of the original request and things can become messy: requests take too much time to get a response, the whole system lags, some service invokations might timeout and if they are not handled properly, there might occur some data loss, users get bored while they wait for the system to do its job, etcetera, etcetera.&lt;/p&gt;
&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;The microservice based architecture provides a method to develop applications that are very decoupled and can be easily scaled so that it fits our needs. But we must also be aware that this design also has flaws and, despite it advantages, we must think twice before using this pattern because it also comes with some flaws.&lt;/p&gt;
&lt;p&gt;I recommend taking a look over &lt;a href="http://microservices.io/index.html"&gt;microservices.io&lt;/a&gt; to read some more design patterns regarding this topic.&lt;/p&gt;</content><category term="distributed"></category><category term="thoughts"></category><category term="microservice"></category></entry><entry><title>What every Python project should have</title><link href="https://vladcalin.github.io/what-every-python-project-should-have.html" rel="alternate"></link><published>2017-01-09T20:21:00+01:00</published><updated>2017-01-10T11:54:00+01:00</updated><author><name>Vlad Calin</name></author><id>tag:vladcalin.github.io,2017-01-09:/what-every-python-project-should-have.html</id><summary type="html">&lt;p&gt;Over the past few years, the Python programming language gained a huge popularity boost
and its community grew faster than ever. With this growth, a lot of tools appeared that
help the community keep things organized and accessible. In this article I am going
to provide a short list of …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Over the past few years, the Python programming language gained a huge popularity boost
and its community grew faster than ever. With this growth, a lot of tools appeared that
help the community keep things organized and accessible. In this article I am going
to provide a short list of items every Python project should have in order to be
accessible and maintainable.&lt;/p&gt;
&lt;h2&gt;requirements.txt&lt;/h2&gt;
&lt;p&gt;Firstly, the &lt;code&gt;requirements.txt&lt;/code&gt; file is crucial for the sanity of those who want to install your project.
It is basically a text file which contains the dependencies to be installed via &lt;code&gt;pip&lt;/code&gt;, one per line. &lt;/p&gt;
&lt;p&gt;It is that simple. And that powerful. &lt;/p&gt;
&lt;p&gt;You can also have multiple &lt;code&gt;requirements.txt&lt;/code&gt; files that serve different purposes. For example,
you can have a &lt;code&gt;requirements.txt&lt;/code&gt; that have general dependencies listed that your project need to run, a &lt;code&gt;requirements_dev.txt&lt;/code&gt; where
you have listed some dependencies that enable some debugging mechanisms and a &lt;code&gt;requirements_docs.txt&lt;/code&gt; that has listed some
requirements that are used when generating the documentation (such as &lt;code&gt;Sphinx&lt;/code&gt; and the desired &lt;code&gt;theme&lt;/code&gt;).&lt;/p&gt;
&lt;h2&gt;setup.py&lt;/h2&gt;
&lt;p&gt;A &lt;code&gt;setup.py&lt;/code&gt; file is crucial for your project if you want to be installable via &lt;code&gt;pip&lt;/code&gt;. It is easy to write, very configurable and takes care of a lot of things such as importing, project metadata, updating the sources, installing the dependencies, and much more.&lt;/p&gt;
&lt;p&gt;You can check the &lt;a href="https://setuptools.readthedocs.io/en/latest/"&gt;setuptools&lt;/a&gt; documentation for more information on this. &lt;/p&gt;
&lt;h2&gt;A proper structure&lt;/h2&gt;
&lt;p&gt;The project structure is crucial. With a well organized structure, it will e easier to organize things, locate certain
source files and encourages other people to contribute.&lt;/p&gt;
&lt;p&gt;The root project directory should have a structure similar to&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root/
        docs/
        tests/
        mymodule/
        scripts/
        requirements.txt
        setup.py
        README
        LICENSE
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Of course, this is not the only way to organize your project, but this certainly is the most
used template.&lt;/p&gt;
&lt;h2&gt;Tests&lt;/h2&gt;
&lt;p&gt;Unit testing is crucial for your project. It allows you to be confident in the stability
of your code. I recommend the &lt;code&gt;unittest&lt;/code&gt; module for this job as it is built in and
is flexible enough to get the job done right. &lt;/p&gt;
&lt;p&gt;There are also other libraries that can be used for testing your project, such as
&lt;code&gt;test.py&lt;/code&gt; or &lt;code&gt;nose&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;Documentation&lt;/h2&gt;
&lt;p&gt;If you develop a project, I am sure that you don't write it just for yourself. Other people
must know how to use your project properly. And even if you write the project only for yourself
(although beats the purpose of open source), after a while of not developing it and when you
come back to it, you will surely not remember anything that is going on in your code (or API).&lt;/p&gt;
&lt;p&gt;So, in order to achieve a reusable code base, you should:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;design a sane API that is easy to use and remember&lt;/li&gt;
&lt;li&gt;the same sane API should be flexible enough to allow easy configurations&lt;/li&gt;
&lt;li&gt;document the most relevant use-cases&lt;/li&gt;
&lt;li&gt;don't try to fit all cases. It should fit only the most usual 80% of cases.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In order to properly document your code, you should use a tool specialized for that job, such
as &lt;code&gt;Sphinx&lt;/code&gt; or &lt;code&gt;mkdocs&lt;/code&gt;, so that you can generate nice-looking documentation with proper
reference links by writing in a popular markup language designed just for that (rst or markdown).&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;After you familiarize yourself with the topics described above, you will surely be able to
produce nice structured projects and libraries that comply to the community standards. And 
don't forget to ALWAYS use PEP-8!&lt;/p&gt;</content><category term="project"></category><category term="python"></category><category term="tips"></category></entry><entry><title>Finally I made myself a blog</title><link href="https://vladcalin.github.io/finally-i-made-myself-a-blog.html" rel="alternate"></link><published>2017-01-07T20:21:00+01:00</published><updated>2017-02-27T20:48:00+01:00</updated><author><name>Vlad Calin</name></author><id>tag:vladcalin.github.io,2017-01-07:/finally-i-made-myself-a-blog.html</id><summary type="html">&lt;p&gt;There is no secret that having a blog is no big deal. Nowdays, everybody can create and host
a blog with ease. So I though... why shouldn't I have a blog?&lt;/p&gt;
&lt;p&gt;I always wanted to write about different things that bug or incite me, write a couple
of words about …&lt;/p&gt;</summary><content type="html">&lt;p&gt;There is no secret that having a blog is no big deal. Nowdays, everybody can create and host
a blog with ease. So I though... why shouldn't I have a blog?&lt;/p&gt;
&lt;p&gt;I always wanted to write about different things that bug or incite me, write a couple
of words about some interesting things I do or see other people do, offer some tips
about the problems that every programmer once had, etc.&lt;/p&gt;
&lt;p&gt;Over the past few days, I searched a method to create a free blog without any major
complications and drama. I researched a little and I tried some of the most popular
choices:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;using Blogger (Google's platform for blogging)&lt;/li&gt;
&lt;li&gt;using Wordpress&lt;/li&gt;
&lt;li&gt;using Jekyll&lt;/li&gt;
&lt;li&gt;using Pelican&lt;/li&gt;
&lt;li&gt;using Hugo&lt;/li&gt;
&lt;li&gt;using Pelican again&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Each of these tools have their strengths and weaknesses. &lt;/p&gt;
&lt;h3&gt;Blogger&lt;/h3&gt;
&lt;p&gt;My first choice was blogger. Why? Because Google owns us, of course.&lt;/p&gt;
&lt;p&gt;Joking aside, it came very easy to start a blog using their platform, as I use Google Chrome as
my main browser and I am logged in with my GMail account. &lt;/p&gt;
&lt;p&gt;The main advantage was that it was easy to start a blog from scratch and publish the first post.
But that was not enough for me. The lack of customization for my blog made me reconsider my choice 
and look further for alternatives. More precisely, they have just a bunch of available themes
and they all look ...  let's just say, not appealing. I had to find something that could be easily 
customizable without loosing its functionality.&lt;/p&gt;
&lt;h3&gt;Wordpress&lt;/h3&gt;
&lt;p&gt;After the Blogger dissapointment, I moved on to Wordpress, the great platform for blogging.
I created an account, I created a blog, I created a new post, published it... but I knew something
was missing... It was all so complicated, everything was so customizable with so many options that 
I was losing myself in those details. &lt;/p&gt;
&lt;p&gt;The next day when I wanted to check out how everything is going, the browser started to crash when I
was accessing their site with an "Out of memory" error. That was unpleasant and frustrating as I was
unable to access the platform. I had to find something else.&lt;/p&gt;
&lt;h3&gt;Jekyll&lt;/h3&gt;
&lt;p&gt;After a while, I heard about some static site generators. I knew, in essence, what they were because I
used Sphinx to convert RST markup to Python documentation, but I never actually got in touch with 
other static site generators other than that. With one search on Google, I found this little tool
named Jekyll (an odd name, to be honest). I followed all their steps in the tutorial and I was
able to generate a mini-blog with a hello world. But I didn't like it because I had to install 
a bunch of useless packages (ruby, gem, some other packages that I had to install because
of some weird errors) just to run Jekyll and generate some HTML pages. Being a Python developer, I said
that there has to be something similar for Python.&lt;/p&gt;
&lt;h3&gt;Pelican&lt;/h3&gt;
&lt;p&gt;After searching for a few minutes, I stumbled upon &lt;strong&gt;Pelican&lt;/strong&gt; - a static site generator written in
Python. After the usual &lt;code&gt;pip install ...&lt;/code&gt; thingy, everything was ready. I followed their tutorial
and found out that everything was so easy... and free... and from the comfort of my own hardware, 
not on the platform of some corporation. It felt right, it was easy, it was fast.&lt;/p&gt;
&lt;h3&gt;Hugo&lt;/h3&gt;
&lt;p&gt;After a while of playing with Pelican I searched for alternatives and I 
found about Hugo, another static site generator, but this time it was 
written in Golang. I said to myself that I should give it a chance. A huge plus
was the huge theme repository that looked better than the ones Pelican provided.&lt;/p&gt;
&lt;p&gt;I downloaded the Hugo executable, created the structure and started to 
search through the themes until I found one that I liked. I used that theme, 
wrote some dummy articles and everything was fine.&lt;/p&gt;
&lt;p&gt;Until the next day, when I decided to trigger a build on other laptop... Long 
story short, everything failed violently and burst into flames because I attempted 
to use the reST syntax, instead of the default Markdown syntax. I later found 
that the reST support is at an early stage, very experimental and it attempts
to run &lt;code&gt;rst2html.py&lt;/code&gt; for whatever Python distribution it finds on your local
machine (and the weird part is that I had &lt;code&gt;docutils&lt;/code&gt; installed, therefore 
the &lt;code&gt;rst2html.py&lt;/code&gt; script was where it was supposed to be, but that Go executable 
was attempting to execute &lt;code&gt;C:\path\to\rst2html.py&lt;/code&gt; as an executable, 
without the use of the Python interpreter.. what the actual Hell).&lt;/p&gt;
&lt;p&gt;After that, I thought that it wasn't a big deal, I could write my articles 
in Markdown.&lt;/p&gt;
&lt;p&gt;But after a few minutes, I researched a little and wanted to do some changes
in the theme templates so that I could customize some things. Then I realized,
when looking over those Go templates that ... damn ... that template language 
was ugly... I certainly liked the Jinja2 templates Pelican uses more than 
the templating language Hugo was using. But this is just my personal opinion 
clearly biased towards Python, Pelican and Jinja2.&lt;/p&gt;
&lt;h3&gt;Back to Pelican&lt;/h3&gt;
&lt;p&gt;After the big Hugo disappointment, I decided to go back to using Pelican. 
In the end, Python is not going to disappoint me, at least not yet.&lt;/p&gt;</content><category term="blog"></category><category term="python"></category></entry></feed>